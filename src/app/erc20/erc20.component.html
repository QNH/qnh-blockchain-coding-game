<h1>ERC20 Tokens</h1>
<p>
  At the moment, we should be connected to an Ethereum network. The means that we can interact with the blockchain of
  that network. This task is all about that: making transactions, deploying (predefined) smart contracts and getting
  data from those.
</p>
<div>
  <h2>Step 1/3: making transactions</h2>
  <p>
    We'll start with the first of those: making a transaction. For this, it is useful to know how you communicate with
    Ethereum. You can communicate in three ways: making a transaction, calling a contract method and listen to events.
    Each of those has a unique function:
  </p>
  <ul>
    <li>Transactions are executions or changes on Ethereum (e.g. transfer Ether);</li>
    <li>With (method) calls, you can ask for data on Ethereum (e.g. get your Ether balance);</li>
    <li>Events are used to detect changes or activities on Ethereum (e.g. when someone transfers Ether)</li>
  </ul>
  <p>
    Ether has been mentioned a bit already. Ether is the 'money' of Ethereum. Ether is used to incentify people to
    start
    mining for the network. If you mine (=execute transactions for the network), you may be rewarded with a little bit
    of
    Ether. This Ether is mainly paid in the transaction that has been mined. Every transaction has a small fee that
    must
    be paid to the miner.
  </p>
  <p>
    The first exercize of this page, it to check our own Ether balance. Next, we will make a transaction by sending
    some
    Ether to someone else. We will cover Events in a later exercize. After sending some Ether, we will deploy our first
    smart contract and learn how to interact with that.
  </p>
  <p>To start interacting with the Ethereum node, open a console window. In this, execute <span class="code">geth
      attach {{nodeAddress}}</span> to connect with the Ethereum node you submitted before. This will not make you a
    node, but instead allows you to use the given node as a sort of API. This will open in form of a JavaScript command
    console, which can be used to execute Javascript code. Both this console, as this web application use a node module
    called Web3js to interact with Ethereum. We will later cover how this node module can be used in a web application.
    For now, it is good to know that this console has access to several modules of its own.
  </p>
  <p>
    The most import one is the <span class="code">eth</span> interface, which is used to interact with the Ethereum
    functions. The first of those function we are going to use is <span class="code">eth.getBalance</span>. This
    function
    will accept two parameters. The first one is the mandatory account address, which you can find in the top right
    corner of the site. The second one is an optional callback. Many functions of Ethereum are asynchronous, meaning
    that
    the code will execute, but not necessarily wait for the code to be executed. Right now, this is not an issue, as we
    just want to display the value, but it might be of relevance later on. For now, just execute the getBalance method
    without callback and check your result.
  </p>
  <p>
    After having done this, we will transfer some Ether to someone else. This is done by making a transaction. As
    stated before, transactions are done to make changes to the network. Transactions can be made as JavaScript objects
    with <span class="code">from</span>, <span class="code">to</span>,
    <span class="code">gas</span>, <span class="code">gasPrice</span> and <span class="code">nonce</span>
    variables. The transaction also has either <span class="code">value</span> for transferring Ether or
    <span class="code">data</span> for interacting with smart contracts, or in rare occassions, both. More info can be
    found in the
    <a href="https://web3js.readthedocs.io/en/1.0/web3-eth.html#eth-sendtransaction">
      sendTransaction section of the Web3 readthedocs
    </a>.
  </p>
  <p>
    Some of these are just configuration of your node. The list below states how to get <span class="code">gas</span>,
    <span class="code">gasPrice</span>, <span class="code">nonce</span>. The from and to should be obvious.
  </p>
  <ul>
    <li>Value has a quirk. Ether is a number with a eighteen decimals. The smallest, whole number of an Ether is a wei.
      In order to transform one Ether to wei for your transaction, you can call <span class="code">web3.toWei(1,
        'Ether')</span>;</li>
    <li>
      the nonce of an account is the amount of transactions it has executed. This can be retrieved by using <span class="code">eth.getTransactionCount({{publicKey}})</span>;
    </li>
    <li>
      gas is a way to express the price of a transaction. On <a href="https://ethgasstation.info/calculatorTxV.php">Eth
        Gas Station</a> you can check the conversion rates between gas, gasPrice and Ether. Each network has its own
      gas limit. Usually, it's good practice to keep it around 4.7 million, as most networks support at least that
      amount of gas;
    </li>
    <li>
      the gasPrice is something that is set in the configuration of the nodes of a network. The higher the gasPrice
      (price in Ether per gas spent), the sooner a node will execute your transaction. gasPrice is expressed in GWei
      (gigawei), and by multiplying the gas used in a transaction with the gasPrice, your get the price in GWei.
      Usually, the gasPrice will be between 1 and 20 GWei (or 0 on some private chains);
    </li>
  </ul>
  <p>
    All of that combined should result in a JavaScript object looking like this:
    <span class="code"><br>
      &nbsp;&nbsp;{{ "{" }}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;from: {{publicKey}},<br>
      &nbsp;&nbsp;&nbsp;&nbsp;to: 0x88e94A4b7BfC62A38D300d98ce1C09f30fb75e3E,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;nonce: 0x04,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gas: 4700000,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;gasPrice: 1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;value: web3.toWei(1, 'Ether')<br>
      &nbsp;&nbsp;{{"}"}}
    </span>
  </p>
  <p>
    There is however a significant difference between calls and transactions. Every change on Ethereum is checked and
    can only be done by the owner of a private key. In order to proof that someone is the actual owner of a key, that
    someone has to cryptographically sign the transaction with that private key. Because the signature of Ethereum is
    asymmetrical, the public key is required to unsign the transaction, proving that the signature is of that public
    key. Before we can actually make the transaction, we have to sign the transaction first. This is where - if you are
    unfamiliar with (asynchronous) JavaScript - it might get a bit complicated. we have to execute two methods. First
    we will sign our signature with <span class="code">eth.signTransaction</span>. This will result is an object with
    the transaction and the raw bytes that make up the signature. We have to input those raw bytes in <span class="code">eth.sendRawTransaction</span>.
  </p>
  <p>
    Executing a transaction may take some time before this is done. While your transaction is being executed, you
    are free to read the following. It will clear up more about the process of miners and executing transactions, but
    the information is not vital to developing blockchain/decentralized apps. If you just want to work on, skip the
    next paragraph.
  </p>
  <p>
    One of the drawbacks of blockchain in general is that every transaction must be executed by the miners of the
    network. Transactions are hashed, and from this hash, a cryptographic puzzle is generated. The miners of the
    network have to solve this puzzle first in order to get paid for mining. This means that having a more powerful
    cryptographic computer, the quicker your computer can solve the puzzles and thus generate more Ether. The puzzle is
    usually compared to having a calculation of prime numbers. You have one prime number and the result. For example,
    your have the prime number 13 and the result 36. Your task is to find what other prime number you need to get 36.
    Once you have this solution, you shout to everyone around you what the solution is, and everyone in the room can
    validate if this is correct. If more than 50% percent agrees with your solution, you and everyone who agreed will
    continue with their chain with that block added. The example calculation and the blockchain puzzle are similar in
    the sense that the puzzle is hard to solve, but easy to validate.
  </p>
  <p>
    After your transaction is done, you will see a long bytecode in the console. This is transaction receipt. If you
    enter <span class="code">eth.getTransaction(receipt)</span>, you can validate that that was the transaction you had
    done. If the printed object has <span class="code">status: "false"</span>, the transaction has failed. If this is
    the case, make sure you do not transfer <i>all</i> your Ether, as you need some for transaction costs (and you will
    need Ether later on)
  </p>
</div>
<div>
  <h2>Step 2/3: make a transaction</h2>
  <p>
    We will, for example, use Javascript todeploy the GenericToken
    contract. This is done by making a transaction.
  </p>
  <p>
    In the root folder of this project, you can find a contracts folder. There are a couple of files in there. For now,
    we will look at the <span class="code">ERC20.sol</span> and <span class="code">GenericToken.sol</span> files. Both
    files are Solidity files, thus a smart contract for the Ethereum network. Feel free to take a look and inspect the
    code. It may look familiar to Javascript. The first file is an interface contract, which lays the structure of an
    ERC20 contract. But what is an ERC20 contract?
  </p>
  <p>
    There are several ERC-contracts. ERC stands for Ethereum Request for Comment, which is a form of standardization
    within the Ethereum Network. Each ERC-contract is a proposal to a solution of a certain problem. This is purely
    community driven, meaning that the ERC-contract is as valuable as the community finds it. The Ethereum Foundation
    has
    a github entirely dedicated to proposing improvements to the Ethereum network. Part of this is these ERC's. ERC's
    are
    made by creating an issue on this page, where the issue ID is the number of the ERC (e.g. issue number 20 is
    ERC20).
    ERC20 is a
    community-standard for tokens, which can be transfered across users and solves the problem of transferring value
    (that is not Ether). ERC20 contracts are widely used to transfer any kind of value and is by now the trading
    standard. If you want to learn more about this standard, you can look this up on <a href="https://github.com/ethereum/eips/issues/20">the
      Ethereum github page</a> or look at <a href="https://theethereum.wiki/w/index.php/ERC20_Token_Standard">the
      Etherum
      wiki</a> to read more on the entire interface and its options.
  </p>
  <p>
    So the <span class="code">ERC20.sol</span> file contains the interface for this standard. Any ERC20 token should
    implement those methods. <span class="code">GenericToken.sol</span> does implement this interface and thus is a
    valid
    ERC20-token.
  </p>
  <p>
    So now we know about the contract, its time to deploy it on the Ethereum network so that we can interact with our
    own
    token. To do so, we first have to compile it into bytescode. Then, we need to make a transaction, in which we tell
    the network to store the contract bytecode. After that, we need to retrieve the contract address and put it on this
    web form below. From there on, we can use this page to interact with that token.
  </p>
  <p>
    So let's start with compiling the code. Open a command window and direct it to the the contracts folder. In there,
    execute <span class="code">solcjs --bin --output-dir "./build" "GenericToken.sol"</span> to compile the <span class="code">GenericToken.sol</span>
    file to binary in the build directory as "GenericToken_sol_GenericToken.bin".
  </p>
  <p>
    Now it's time to deploy this contract to the network. For this, open up another command window.
  </p>
</div>
<div>
  <h2>Step 3/3: track your tokens</h2>
  <table class="tokens">
    <tr *ngFor="let token of _tokens">
      <td class="token" [attr.data-address]="token.address">
        <p>{{token.address}}</p>
      </td>
    </tr>
    <tr>
      <td>
        <input [(ngModel)]="_newTokenAddress" placeholder="Add new token address" />
        <button (click)="addToken()">Add token</button>
      </td>
    </tr>
  </table>
